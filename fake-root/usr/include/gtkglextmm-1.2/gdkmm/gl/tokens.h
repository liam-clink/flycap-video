// -*- c++ -*-
// Generated by gtkmmproc -- DO NOT MODIFY!
#ifndef _GDKMM_GL_TOKENS_H
#define _GDKMM_GL_TOKENS_H

#include <glibmm.h>

// -*- C++ -*-
/* gdkglextmm - C++ Wrapper for GdkGLExt
 * Copyright (C) 2002-2003  Naofumi Yasufuku
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA.
 */

#include <gdkmm/gl/defs.h>


namespace Gdk
{
namespace GL
{

GDKMM_GL_VAR const int SUCCESS;

GDKMM_GL_VAR const int ATTRIB_LIST_NONE;

GDKMM_GL_VAR const int DONT_CARE;

GDKMM_GL_VAR const int NONE;

} // namespace GL
} // namespace Gdk

namespace Gdk
{
namespace GL
{

/** @addtogroup gdkmm_glEnums Enums and Flags */

/**
 * @ingroup gdkmm_glEnums
 */
enum ConfigAttrib
{
  USE_GL = 1,
  BUFFER_SIZE = 2,
  LEVEL = 3,
  RGBA = 4,
  DOUBLEBUFFER = 5,
  STEREO = 6,
  AUX_BUFFERS = 7,
  RED_SIZE = 8,
  GREEN_SIZE = 9,
  BLUE_SIZE = 10,
  ALPHA_SIZE = 11,
  DEPTH_SIZE = 12,
  STENCIL_SIZE = 13,
  ACCUM_RED_SIZE = 14,
  ACCUM_GREEN_SIZE = 15,
  ACCUM_BLUE_SIZE = 16,
  ACCUM_ALPHA_SIZE = 17,
  CONFIG_CAVEAT = 0x20,
  X_VISUAL_TYPE = 0x22,
  TRANSPARENT_TYPE = 0x23,
  TRANSPARENT_INDEX_VALUE = 0x24,
  TRANSPARENT_RED_VALUE = 0x25,
  TRANSPARENT_GREEN_VALUE = 0x26,
  TRANSPARENT_BLUE_VALUE = 0x27,
  TRANSPARENT_ALPHA_VALUE = 0x28,
  DRAWABLE_TYPE = 0x8010,
  RENDER_TYPE = 0x8011,
  X_RENDERABLE = 0x8012,
  FBCONFIG_ID = 0x8013,
  MAX_PBUFFER_WIDTH = 0x8016,
  MAX_PBUFFER_HEIGHT = 0x8017,
  MAX_PBUFFER_PIXELS = 0x8018,
  VISUAL_ID = 0x800B,
  SCREEN = 0x800C,
  SAMPLE_BUFFERS = 100000,
  SAMPLES = 100001
};

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::ConfigAttrib> : public Glib::Value_Enum<Gdk::GL::ConfigAttrib>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 */
enum ConfigCaveat
{
  CONFIG_CAVEAT_DONT_CARE = 0xFFFFFFFF,
  CONFIG_CAVEAT_NONE = 0x8000,
  SLOW_CONFIG = 0x8001,
  NON_CONFORMANT_CONFIG = 0x800D
};

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::ConfigCaveat> : public Glib::Value_Enum<Gdk::GL::ConfigCaveat>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 */
enum VisualType
{
  VISUAL_TYPE_DONT_CARE = 0xFFFFFFFF,
  TRUE_COLOR = 0x8002,
  DIRECT_COLOR = 0x8003,
  PSEUDO_COLOR = 0x8004,
  STATIC_COLOR = 0x8005,
  GRAY_SCALE = 0x8006,
  STATIC_GRAY = 0x8007
};

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::VisualType> : public Glib::Value_Enum<Gdk::GL::VisualType>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 */
enum TransparentType
{
  TRANSPARENT_NONE = 0x8000,
  TRANSPARENT_RGB = 0x8008,
  TRANSPARENT_INDEX = 0x8009
};

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::TransparentType> : public Glib::Value_Enum<Gdk::GL::TransparentType>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 * @par Bitwise operators:
 * <tt>%DrawableTypeMask operator|(DrawableTypeMask, DrawableTypeMask)</tt><br>
 * <tt>%DrawableTypeMask operator&(DrawableTypeMask, DrawableTypeMask)</tt><br>
 * <tt>%DrawableTypeMask operator^(DrawableTypeMask, DrawableTypeMask)</tt><br>
 * <tt>%DrawableTypeMask operator~(DrawableTypeMask)</tt><br>
 * <tt>%DrawableTypeMask& operator|=(DrawableTypeMask&, DrawableTypeMask)</tt><br>
 * <tt>%DrawableTypeMask& operator&=(DrawableTypeMask&, DrawableTypeMask)</tt><br>
 * <tt>%DrawableTypeMask& operator^=(DrawableTypeMask&, DrawableTypeMask)</tt><br>
 */
enum DrawableTypeMask
{
  WINDOW_BIT = 1 << 0,
  PIXMAP_BIT = 1 << 1,
  PBUFFER_BIT = 1 << 2
};

/** @ingroup gdkmm_glEnums */
inline DrawableTypeMask operator|(DrawableTypeMask lhs, DrawableTypeMask rhs)
  { return static_cast<DrawableTypeMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }

/** @ingroup gdkmm_glEnums */
inline DrawableTypeMask operator&(DrawableTypeMask lhs, DrawableTypeMask rhs)
  { return static_cast<DrawableTypeMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }

/** @ingroup gdkmm_glEnums */
inline DrawableTypeMask operator^(DrawableTypeMask lhs, DrawableTypeMask rhs)
  { return static_cast<DrawableTypeMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }

/** @ingroup gdkmm_glEnums */
inline DrawableTypeMask operator~(DrawableTypeMask flags)
  { return static_cast<DrawableTypeMask>(~static_cast<unsigned>(flags)); }

/** @ingroup gdkmm_glEnums */
inline DrawableTypeMask& operator|=(DrawableTypeMask& lhs, DrawableTypeMask rhs)
  { return (lhs = static_cast<DrawableTypeMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }

/** @ingroup gdkmm_glEnums */
inline DrawableTypeMask& operator&=(DrawableTypeMask& lhs, DrawableTypeMask rhs)
  { return (lhs = static_cast<DrawableTypeMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }

/** @ingroup gdkmm_glEnums */
inline DrawableTypeMask& operator^=(DrawableTypeMask& lhs, DrawableTypeMask rhs)
  { return (lhs = static_cast<DrawableTypeMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::DrawableTypeMask> : public Glib::Value_Flags<Gdk::GL::DrawableTypeMask>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 * @par Bitwise operators:
 * <tt>%RenderTypeMask operator|(RenderTypeMask, RenderTypeMask)</tt><br>
 * <tt>%RenderTypeMask operator&(RenderTypeMask, RenderTypeMask)</tt><br>
 * <tt>%RenderTypeMask operator^(RenderTypeMask, RenderTypeMask)</tt><br>
 * <tt>%RenderTypeMask operator~(RenderTypeMask)</tt><br>
 * <tt>%RenderTypeMask& operator|=(RenderTypeMask&, RenderTypeMask)</tt><br>
 * <tt>%RenderTypeMask& operator&=(RenderTypeMask&, RenderTypeMask)</tt><br>
 * <tt>%RenderTypeMask& operator^=(RenderTypeMask&, RenderTypeMask)</tt><br>
 */
enum RenderTypeMask
{
  RGBA_BIT = 1 << 0,
  COLOR_INDEX_BIT = 1 << 1
};

/** @ingroup gdkmm_glEnums */
inline RenderTypeMask operator|(RenderTypeMask lhs, RenderTypeMask rhs)
  { return static_cast<RenderTypeMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }

/** @ingroup gdkmm_glEnums */
inline RenderTypeMask operator&(RenderTypeMask lhs, RenderTypeMask rhs)
  { return static_cast<RenderTypeMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }

/** @ingroup gdkmm_glEnums */
inline RenderTypeMask operator^(RenderTypeMask lhs, RenderTypeMask rhs)
  { return static_cast<RenderTypeMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }

/** @ingroup gdkmm_glEnums */
inline RenderTypeMask operator~(RenderTypeMask flags)
  { return static_cast<RenderTypeMask>(~static_cast<unsigned>(flags)); }

/** @ingroup gdkmm_glEnums */
inline RenderTypeMask& operator|=(RenderTypeMask& lhs, RenderTypeMask rhs)
  { return (lhs = static_cast<RenderTypeMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }

/** @ingroup gdkmm_glEnums */
inline RenderTypeMask& operator&=(RenderTypeMask& lhs, RenderTypeMask rhs)
  { return (lhs = static_cast<RenderTypeMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }

/** @ingroup gdkmm_glEnums */
inline RenderTypeMask& operator^=(RenderTypeMask& lhs, RenderTypeMask rhs)
  { return (lhs = static_cast<RenderTypeMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::RenderTypeMask> : public Glib::Value_Flags<Gdk::GL::RenderTypeMask>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 * @par Bitwise operators:
 * <tt>%BufferMask operator|(BufferMask, BufferMask)</tt><br>
 * <tt>%BufferMask operator&(BufferMask, BufferMask)</tt><br>
 * <tt>%BufferMask operator^(BufferMask, BufferMask)</tt><br>
 * <tt>%BufferMask operator~(BufferMask)</tt><br>
 * <tt>%BufferMask& operator|=(BufferMask&, BufferMask)</tt><br>
 * <tt>%BufferMask& operator&=(BufferMask&, BufferMask)</tt><br>
 * <tt>%BufferMask& operator^=(BufferMask&, BufferMask)</tt><br>
 */
enum BufferMask
{
  FRONT_LEFT_BUFFER_BIT = 1 << 0,
  FRONT_RIGHT_BUFFER_BIT = 1 << 1,
  BACK_LEFT_BUFFER_BIT = 1 << 2,
  BACK_RIGHT_BUFFER_BIT = 1 << 3,
  AUX_BUFFERS_BIT = 1 << 4,
  DEPTH_BUFFER_BIT = 1 << 5,
  STENCIL_BUFFER_BIT = 1 << 6,
  ACCUM_BUFFER_BIT = 1 << 7
};

/** @ingroup gdkmm_glEnums */
inline BufferMask operator|(BufferMask lhs, BufferMask rhs)
  { return static_cast<BufferMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }

/** @ingroup gdkmm_glEnums */
inline BufferMask operator&(BufferMask lhs, BufferMask rhs)
  { return static_cast<BufferMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }

/** @ingroup gdkmm_glEnums */
inline BufferMask operator^(BufferMask lhs, BufferMask rhs)
  { return static_cast<BufferMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }

/** @ingroup gdkmm_glEnums */
inline BufferMask operator~(BufferMask flags)
  { return static_cast<BufferMask>(~static_cast<unsigned>(flags)); }

/** @ingroup gdkmm_glEnums */
inline BufferMask& operator|=(BufferMask& lhs, BufferMask rhs)
  { return (lhs = static_cast<BufferMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }

/** @ingroup gdkmm_glEnums */
inline BufferMask& operator&=(BufferMask& lhs, BufferMask rhs)
  { return (lhs = static_cast<BufferMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }

/** @ingroup gdkmm_glEnums */
inline BufferMask& operator^=(BufferMask& lhs, BufferMask rhs)
  { return (lhs = static_cast<BufferMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::BufferMask> : public Glib::Value_Flags<Gdk::GL::BufferMask>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 */
enum ConfigError
{
  BAD_SCREEN = 1,
  BAD_ATTRIBUTE,
  NO_EXTENSION,
  BAD_VISUAL,
  BAD_CONTEXT,
  BAD_VALUE,
  BAD_ENUM
};

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::ConfigError> : public Glib::Value_Enum<Gdk::GL::ConfigError>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 */
enum RenderType
{
  RGBA_TYPE = 0x8014,
  COLOR_INDEX_TYPE = 0x8015
};

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::RenderType> : public Glib::Value_Enum<Gdk::GL::RenderType>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 */
enum DrawableAttrib
{
  PRESERVED_CONTENTS = 0x801B,
  LARGEST_PBUFFER = 0x801C,
  WIDTH = 0x801D,
  HEIGHT = 0x801E,
  EVENT_MASK = 0x801F
};

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::DrawableAttrib> : public Glib::Value_Enum<Gdk::GL::DrawableAttrib>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 */
enum PbufferAttrib
{
  PBUFFER_PRESERVED_CONTENTS = 0x801B,
  PBUFFER_LARGEST_PBUFFER = 0x801C,
  PBUFFER_HEIGHT = 0x8040,
  PBUFFER_WIDTH = 0x8041
};

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::PbufferAttrib> : public Glib::Value_Enum<Gdk::GL::PbufferAttrib>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 * @par Bitwise operators:
 * <tt>%EventMask operator|(EventMask, EventMask)</tt><br>
 * <tt>%EventMask operator&(EventMask, EventMask)</tt><br>
 * <tt>%EventMask operator^(EventMask, EventMask)</tt><br>
 * <tt>%EventMask operator~(EventMask)</tt><br>
 * <tt>%EventMask& operator|=(EventMask&, EventMask)</tt><br>
 * <tt>%EventMask& operator&=(EventMask&, EventMask)</tt><br>
 * <tt>%EventMask& operator^=(EventMask&, EventMask)</tt><br>
 */
enum EventMask
{
  PBUFFER_CLOBBER_MASK = 1 << 27
};

/** @ingroup gdkmm_glEnums */
inline EventMask operator|(EventMask lhs, EventMask rhs)
  { return static_cast<EventMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }

/** @ingroup gdkmm_glEnums */
inline EventMask operator&(EventMask lhs, EventMask rhs)
  { return static_cast<EventMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }

/** @ingroup gdkmm_glEnums */
inline EventMask operator^(EventMask lhs, EventMask rhs)
  { return static_cast<EventMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }

/** @ingroup gdkmm_glEnums */
inline EventMask operator~(EventMask flags)
  { return static_cast<EventMask>(~static_cast<unsigned>(flags)); }

/** @ingroup gdkmm_glEnums */
inline EventMask& operator|=(EventMask& lhs, EventMask rhs)
  { return (lhs = static_cast<EventMask>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }

/** @ingroup gdkmm_glEnums */
inline EventMask& operator&=(EventMask& lhs, EventMask rhs)
  { return (lhs = static_cast<EventMask>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }

/** @ingroup gdkmm_glEnums */
inline EventMask& operator^=(EventMask& lhs, EventMask rhs)
  { return (lhs = static_cast<EventMask>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::EventMask> : public Glib::Value_Flags<Gdk::GL::EventMask>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 */
enum EventType
{
  DAMAGED = 0x8020,
  SAVED = 0x8021
};

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::EventType> : public Glib::Value_Enum<Gdk::GL::EventType>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


/**
 * @ingroup gdkmm_glEnums
 */
enum DrawableType
{
  WINDOW = 0x8022,
  PBUFFER = 0x8023
};

} // namespace GL

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::GL::DrawableType> : public Glib::Value_Enum<Gdk::GL::DrawableType>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{

namespace GL
{


} // namespace GL
} // namespace Gdk

#endif /* _GDKMM_GL_TOKENS_H */

